-- 2일차 4교시 스프링 레거시--
스프링 프로젝트는 메이븐을 빌드도구로 끼고 한다.

src/test/java 는 JUnit 같은 테스트를 위한 것이다.
src/test/resources 는 xml같은 설정파일같은 거

src/main/java와 src/main/resources 만 배포할 때 쓴다.

기본적으로 스프링은 MVC프로젝트이다.

maven은 pom.xml이 있다. project object model 프로젝트를 관리하는 설정파일

빌드도구 : 프로젝트를 최종적으로 배포할 수 있도록 해주는 도구
컴파일 빌드 등등
pom.xml에서 라이브러리를 관리한다.
dependency 한개한개가 라이브러리 정보이다.

src폴더 밑에 webapp이라는 폴더가 외부에 공개되어 있다.(기준폴더)
외부에서 주소를 쳐서 접근 가능한 폴더이다.
WEB-INF는 비공개.

모델1: webapp에서 직접적으로 jsp 요청
모델2: MVC패턴 

모델1은 서버코드와 브라우저코드와 함께
모델2(MVC)는 컨트롤러 < - > 모델 , 컨트롤러 < - > 뷰
------------------------------------------------------------

-- 2일차 5교시 jsp로 변환--
HTML(부트스트랩으로 작성한 것을) jsp로 변환했다.
프로젝트 우클릭 속성 projectFacet 서버runtime 추가
------------------------------------------------------------

--2일차 6교시는 모듈화 작업, views로 옮기기--
include 폴더 만들고 푸터, 헤드, 네브, 자바스크립트를 만든다
<%-- --> 이거는 서버주석으로 불리며 브라우저가 출력 안한다. 
<!-- --> 이거는 브라우저 주석
<jsp: include page"/include/topNavbar.jsp"></jsp:include>
슬러시를 맨앞에 붙여주면 webapp에서 시작하므로 절대주소같다.

WEB-INF의 views 폴더로 작업파일 및 폴더 옮기기!
css, js, images 같은 것들은 webapp하위에 있는 resources폴더로 옮긴다.
그런다음 빨간줄 뜨는데 주소를 전부 수정해주면된다.(WEB-INF로)
------------------------------------------------------------

--2일차 7교시 @Controller와 컨트롤러class, EL언어 언급(${org.springframework-version} --
HomeController의 설명
스프링은 애너테이션기반(@Controller)
(예시) 클래스위에 @Controller를 붙이면 컨트롤러 역할을하는 클래스가 된다.

@Controller
public class HomeController{
	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);
}

컨트롤 + 시프트 + o 누르면 import가 자동 정리된다.
컨트롤 + 시프트 + f 누르면 줄정렬이 자동으로 된다.

메이븐 저장소(mavenrepository) 검색어: springcontext(버전5.2.16 릴리즈), servlet(4.0.1)
pom.xml에서 <properties>는 변수 이름, <dependencies>는 의존성이 있는 라이브러리를 명시한다. 
<dependency>가 개별 라이브러리이다.
c -> 사용자 -> .m2 -> repository(로컬저장소) 메이븐은 원격저장소

[pom.xml 수정한 것]
{
	<java-version>1.8</java-version>
	<org.springframework-version>5.2.16.RELEASE</org.springframework-version>

	<dependencies>
		<dependency>
			servlet버전 4.0.1
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				maven-compiler-plugin 3.8.1
				configuration 버전 source와 target을 ${java-version}
			</plugin>
		</plugins>
	</build>
} 수정후에는 maven update project를 꼭 해줘라.

[servlet-context.xml]
{
	InternalResourceViewResolver에 프리픽스와 서픽스 값을 봐라
}


@Controller
public class HomeController{
	
	@GetMapping(value = "/") (value는 생략가능하다)
	public void Home(){
		System.out.println("home() 출력됨...);
	return "/WEB-INF/views/index.jsp"; 이거를
	return "index"; 요렇게 해라
	}
}

서버에 Add and Remove설정법과 Web Modules에서 Path를 /로 바꾸기

스프링프레임워크가 우리의 코드를 사용하는 것이다.
3일차 1교시에 Dispatcherservlet 이걸 배울 것이다.

------------------------------------------------------------
-- 3일차 1교시 서블릿 설명--
스프링레거시와 스프링부트가 있다.
스프링은 설정이 반이다.
pom.xml은 maven이 쓴다.
web.xml은 tomcat이 쓴다.

톰캣은 서블릿 jsp 컨테이너, jsp도 서블릿 클래스로 변환되어서 실행된다.
톰캣은 하나의 서블릿을 실행하는 플랫폼

서블릿 설정하는 방식이 2가지가 있다.
1. 애너테이션으로 등록
2. <servlet></servlet>이런식으로 하는 방법 servlet-class는 httpservlet을 상속받음.

<servlet>
	<servlet-name>myController</servlet-name>
	<servlet-class>ch18.com.controller.MyController</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>myController</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>

위에 두개는 myController로 연결된다.

jsp교재 619에 HttpServlet을 상속받으면 doPost 등을 쓸 수 있게 되는 것이다.
요청만 처리하는 것에는 servlet이 효율적이므로 jsp를 안쓰고 servlet을 쓴다.
스프링프레임워크는 Dispatcher서블릿과 
톰캣이 프레임워크로 봐도 된다. doGet같은걸 호출하는게 안보임
------------------------------------------------------------
-- 3일차 2교시 web.xml설정, DispatcherServlet --
web.xml 설정
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="4.0" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee;(여기에 세미콜론 넣으면 빨간줄 사라짐) https://java.sun.com/xml/ns/javaee/web-app_4_0.xsd">

listener에 대해 설명(ContextLoaderListener) 프로그램 로드 리스너. 톰캣이 최초 기동 될 때 
스프링이 사용하는 설정파일을 읽어들이는 것
리스너는 미리 등록한 약속된 작업을 해주는 것
톰캣이 web.xml 파싱 -> 리스너 실행 -> context-param을 가져간다(setContext~~) -> root-context.xml
안드로이드도 스프링으로 가능함.

스프링은 DispatcherServlet이 전면에 등장. 역할은 프론트컨트롤러인데 실제론 서블릿
p621 
1. if(command.equals("/BoardWriteAction.do")){
(이게 @GetMapping("/")이다.

2.	requestBoardWrite(request);( 이게 HomeController에서 String home()메서드이다.)

3.	RequestDispatcher rd = request.getRequestDispatcher("/BoardListAction.do");
	(이게 HomeController에서 return "index"; 부분이다)

	rd.forward(request, response);
}

DispatcherServlet은 위에 621이 제공하는것을 포함하고, 더 다양한 것을 제공한다.
appServlet의 servlet-context.xml이 핵심엔진

bean은 object이고 스프링이 사용하는 객체를 뜻한다.

servlet-context.xml의 <annotation-driven/>있는데 
이것은 @Controller가 마킹되어 있는 것(해당클래스)을
DispatcherServlet이 호출할 수 있게 하는 프로그램
@Controller가 빠지면 DispatcherServlet이 인식못함.
2~3(621 14~15줄)을 스프링에서는 자동으로 생성해주는 것이다.

root-context.xml은 데이터베이스 관련된 것을 설정하는 곳이다.
------------------------------------------------------------
-- 3일차 3교시 pom.xml설정, DB pool --
<load-on-startup>1</load-on-startup> 이거는 첫번째 요청한 사람도 딜레이없이 빠르게 응답받도록
요청~ 서블릿 이런 패턴을 여러개 만들 수 있다.
그 때 1이라고 하면 우선순위가 높은 것이다.
[pom.xml 수정한 것]
{
	<dependencies>
		<dependency>
			Spring TestContext Framework 5.2.16.RELEASE
			Spring JDBC 5.2.16.RELEASE
			Spring Transaction 5.2.16.RELEASE
			마이바티스 3.5.7
			마이바티스-spring 2.0.6
			Mysql Connector 8.0.26(DB연결 드라이버)
			com.zaxxer에 HikariCP 5.0.0
			Project Lombok 1.18.20
			Junit 4.12
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
		
			</plugin>
		</plugins>
	</build>
} 수정후에는 maven update project를 꼭 해줘라.
마이바티스(DB반복작업 도와주는 모듈, 스프링이랑 연동)
JPA
------------------------------------------------------------
-- 3일차 4교시 pom.xml설정, MVC패턴,lombok으로 get set 자동처리--
com.example.controller 패키지
 -> HomeController 이거 설명
순수클래스(POJO 플레인 올드 자바 오브젝트)

@Controller
@RequestMapping("/member/*")->주소에서 공통적인 경로를 class수준에서 정의할 수 있다.
public class MemberController{
	@GetMapping("join") ->이거는 .do랑 비슷한거
	public String join(){
	System.out.println("join 호출됨...");
	return "member/join";
	}	
} DispatcherServlet이 받아서 실행

topNavbar에서 a 태그의 회원가입 부분에서 .jsp 삭제
http://localhost:8090/member/join
주소표시줄로 요청하는 것은 Get방식이므로 @Getmapping 해줘야한다.

주소에서 공통적인 경로를 class수준에서 정의할 수 있다.
@RequestMapping("/member/*") -> 멤버뒤에 무언가 온다~

topNavbar에서 a 태그의 Home 부분 /index.jsp를 삭제하고 /만 남긴다.
topNavbar에서 a 태그의 android 부분 /index.jsp를 삭제하고 /만 남긴다.

join.jsp에서 input부분 name속성! 서버에서 값을 찾는 기준이된다. request객체로 
사용자데이터가 넘어올텐데, request.getParameter()로 꺼내쓰기했다. 

button type에 submit이 있으면 가장 가까운 form태그의 action을 요청한다.(submit request)
<form action = "/member/join" method="POST">

@Controller
@RequestMapping("/member/*")->주소에서 공통적인 경로를 class수준에서 정의할 수 있다.
public class MemberController{
	@GetMapping("join") ->이거는 .do랑 비슷한거
	public String join(){
	System.out.println("join 호출됨...");
	return "member/join";
	}	

	@PostMapping("join")
	public void join(String id){
		
	}
} DispatcherServlet이 받아서 실행

post는 용량제한이 없고, get은 200바이트정도제한

------------------------------------------------------------
-- 3일차 5교시 lombok으로 get set 자동처리 toString--
@Controller
@RequestMapping("/member/*")->주소에서 공통적인 경로를 class수준에서 정의할 수 있다.
public class MemberController{

	@GetMapping("join") ->이거는 .do랑 비슷한거
	public String join(){
	System.out.println("join 호출됨...");
	return "member/join";
	}	

	@PostMapping("join")
	public void join(String id){
		
	}
} DispatcherServlet이 받아서 실행

액션태그를 스프링이 자동으로 해준다.(규칙만 알면된다)

정적인것은 아파치가 해줄 수 있고
동적인 것은 톰캣이 받아서 DispatcherServlet이 받아서 코드를 호출

form태그에서 submit버튼에 의하여 데이터가 MemberController넘어오게 된다.

jsp 또는 서블릿이면 request가 기본내장객체로 준비되어 있다. 그래서 ..<% request.getParameter("id")%>
이렇게 처리 될 테지만~

스프링4버전이후 자바 리플렉션기술이 있기에 실행중에 확인 할 수 있다. 그래서결론은 name값만 써주면됨
@PostMapping("join")
public void join(HttpServletRequest request){ request.getParameter("id"); } 
DispatcherServlet아 이 request객체 주세요~ 이렇게 하는건 스프링방식은 아님.. 그냥 톰캣기반

@PostMapping("join")
public void join(String id, String passwd, String name){ id와 비밀번호는 문자열로 
	System.out.println("id : " + id);
	System.out.println("passwd : " + passwd);
	System.out.println("name : " + name);
} post요청에서는 한글이 깨진다.

Filter 처리하면 한글제대로 보임(web.xml)

	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

DB테이블과 관련된 정보를 자바입장에서는 객체형태로 준비했다가 insert문으로 DB에 넣을 것이다.
튜플을 담을 수 있는 VO클래스 또는 dto 정의 value object
VO: 데이터베이스 테이블관련
dto: 프로그램 내부적으로 데이터 모아서 이동시키는 용도
DB간에 대소문자로 인한 오류 소거하기 위해서 캐멀(낙타)표기법으로 하자

전체를 불러오려면 object에서 상속받는 toString을 자동으로~ 

@
package com.example.domain;

import java.util.Date;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

public class MemberVO {
	private String id;
	private String passwd;
	private String name;
	private String birthday;
	private String gender;
	private String email;
	private String recvEmail;
	private Date regDate;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getPasswd() {
		return passwd;
	}
	public void setPasswd(String passwd) {
		this.passwd = passwd;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getBirthday() {
		return birthday;
	}
	public void setBirthday(String birthday) {
		this.birthday = birthday;
	}
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getRecvEmail() {
		return recvEmail;
	}
	public void setRecvEmail(String recvEmail) {
		this.recvEmail = recvEmail;
	}
	public Date getRegDate() {
		return regDate;
	}
	public void setRegDate(Date regDate) {
		this.regDate = regDate;
	}
	@Override
	public String toString() {
		return "MemberVO [id=" + id + ", passwd=" + passwd + ", name=" + name + ", birthday=" + birthday + ", gender="
				+ gender + ", email=" + email + ", recvEmail=" + recvEmail + ", regDate=" + regDate + "]";
	}
	
}

------------------------------------------------------------
-- 3일차 6교시 java -jar lombok.jar 설치해야 아웃라인이 나온다, DI개념 설명(Car), 마이바티스 --
package com.example.domain;

import java.util.Date;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@AllArgsConstructor(모든 것을 나오게하는 생성자~)
@NoArgsConstructor
@Getter
@Setter
@ToString(모든 멤버변수)
public class MemberVO {
	private String id;
	private String passwd;
	private String name;
	private String birthday;
	private String gender;
	private String email;
	private String recvEmail;
	private Date regDate;

}

VO에 있는 멤버변수랑 form태그의 name값이랑 같게 설정해주자! 그래야 스프링이 자동으로 가능

@Controller
@RequestMapping("/member/*")->주소에서 공통적인 경로를 class수준에서 정의할 수 있다.
public class MemberController{

	@GetMapping("join") ->이거는 .do랑 비슷한거
	public String join(){
	System.out.println("join 호출됨...");
	return "member/join";
	}	

	@PostMapping("join")
	public void join(MemberVO memberVO){
		System.out.println(memberVO)
	}
} DispatcherServlet이 받아서 실행

get set 기본생성자 있으면 작동되는데, setter메서드의 
뒷부분setId이런거의 Id부분을 id로 고쳐서 스프링(DispatcherServlet)이 자동인식하고 처리함
작성일자는 시스템에서 만들어준다. 그러므로 7개가 설정하는 것
jdbc코드로 insert를 하면 스프링 쓰는 의미가 없으므로 마이바티스모듈을 이용하려고 한다.

대부분 포함관계이고
public class Car {
	private ToyotaEngine toyotaEngine;
}

repositoryDAO객체가 모델2에서 보드컨트롤러 안에 있었고,
보드컨트롤러가 단독으로 처리할 수 없고, repositoryDAO와 협력하여 같이 처리한다.
제대로된 DB연동을 위하여~ 의존하고 있다... 자동차와 엔진관계 또는 스마트폰과 배터리관계



------------------------------------------------------------
-- 3일차 7교시 DI개념 설명(Car)  --
interface Engine{ 엔진제조업체들은 이 인터페이스를 따른다.
	void start();
}

class HyundaiEngine implement Engine{
	@Override
	public void start() {
	System.out.println("현대 엔진이 동작: 부릉부릉~");
}

업캐스팅: Engine engine = new ToyotaEngine(); 엔진이 상위 도요타엔진이 하위

우리의 목표는 엔진이 바뀌더라도 Car class는 전혀 손대지 않아도 되게끔 하는 것

외부에서 new하기

class Car {
	private Engine engine;

	public Car(Engine engine){
	super();
	this.engine = engine;

	public void setEngine(Engine engine){
	this.engine = engine;
	}

	public void drive(){
	engine.start();
	}
}


public static void main(String[] args){
	Engine engine = new ToyotaEngine();

	Car car = new Car(engine); 자동차가 엔진을 의존한다. 의존관계 주입을 수동으로 했다.
	car.drive();

	engine = FordEngine();
	car.setEngine(engine);

	car.setEngine(new HyundaiEngine());
	car.drive();
}


DB설정은 root-context.xml에서 설정해준다.
스프링이 관리하는객체를 beans라고 한다.
		<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
			<property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
			<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/jspdb?useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true&amp;useSSL=false&amp;serverTimezone=Asia/Seoul" />
			<property name="username" value="jspid" />
			<property name="password" value="jsppass" />
		</bean>
Mysql 네이버카페젠코딩에서 jdbcUrl 복사
&이거를 &amp; 요렇게 고치기
------------------------------------------------------------
-- 4일차 1교시 Car와 Engine 설명(포함관계와 DI개념,@Component), JUnit테스트방법--
DispatcherServlet에게 모든 것을 결재받아야 한다.
클래스 만들 때 Add해서 인터페이스 넣기가능

root-context의 Namespace에서 bean, context, mybatis, tx 체크

@Component 마크와 스캔
root-context.xml에서 <context:component-scan base-package = "com.example.sample" />
의존관계 주입하는 거는 @Autowired로 해준다.(Car car = new Car(engine);이런거)
@Autowired
public Car(Engine engine){
	this.engine = engine;
}
src/test/java
com.example.sample 패키지 생성
SampleTests 클래스 를 만들고, 테스트 진행 할 것
@Component 스프링빈 표시(카, 현대엔진 마킹했다면 둘다 객체가 준비가 될것이다.)
생성자에 박으면, 순서도 스프링이 자동으로 해준다.

@Autowired 는 타입을 기준으로 스프링빈 안에서 의존객체를 찾아서 주입해준다.
root-context.xml에서
<context:component-scan base-package="com.example.sample" />

@RunWith(SpringJUnit4ClassRunner.class)//@Component 계열 애노테이션에 해당함
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
이걸 해주면 JUnit테스트 가능
------------------------------------------------------------
-- 4일차 2교시 스프링에서 어노테이션작동원리(Car와 현대엔진), 맵컬렉션--
pom.xml에서 Junit버전을 4.12
assertNotNull(여기에 널이 아니면 테스트 통과)
root-context.xml에서
<context:component-scan base-package="com.example.sample" />
root에서 스캔한 것만 스프링이 인식
애너테이션 관련 프로그램 발전으로 일일이 <bean>안해도 된다.
setter를 통해서는 Autowired 필수
생성자 통해서 할 때는 Autowired 생략가능
Map<String, Object> map = new HashMap<String, Object>();
	@Test
	public void testMap() {
		Map<String, Car> map = new HashMap<String, Car>();
		//키로 제일많이 쓰는 건 String이고, 값으로 Object많이 씀
		map.put("현대자동차", new Car(new HyundaiEngine()));
		map.put("포드자동차", new Car(new FordEngine()));
		Car hyundaiCar = map.get("현대자동차");
		hyundaiCar.drive();
		
		Car FordCar = map.get("포드자동차");
		FordCar.drive();
				
	}
------------------------------------------------------------
-- 4일차 3교시 --
1. @Component 2. @Autowired 3. root-context.xml에서 <context:component-scan base-package="com.example.sample" />
map컬렉션에서 put의 키가 중복되는 경우: 수정하는 것

<!-- @Component랑 용도가 같은 bean! -->
root-context.xml에서 히카리 설명은 스킵(14분경)..
		<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
			<property name="driverClassName" value="com.mysql.cj.jdbc.Driver" />
			<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/jspdb?useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true&amp;useSSL=false&amp;serverTimezone=Asia/Seoul" />
			<property name="username" value="jspid" />
			<property name="password" value="jsppass" />
		</bean>
		
		<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
			<constructor-arg ref="hikariConfig" />
		</bean>
닫아주는 거 destroy-method="close"
스프링에서 일일이 bean설정 해줬던 때 설명
커넥션 풀 준비 끝
mybatis-config.xml은 src/main/resources폴더에 만든다.
구글에서 mybatis공식사이트에서 시작하기
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

	<settings>
		<!-- DB에서 데이터 조회 또는 삽입 등에서 null값 허용 -->
		<setting name="jdbcTypeForNull" value="NULL"/>
		<setting name="callSettersOnNulls" value="true"/>
		
		<!-- 동일한 select문이 또 요청되면 기존 캐시된 내용으로 가져옴. 속도향상 -->
		<setting name="cacheEnabled" value="true"/>
		
		<!-- 테이블의 컬럼명과 VO객체의 setter명 연결 규칙 설정 -->
		<setting name="mapUnderscoreToCamelCase" value="true"/>
	</settings>
	
	<typeAliases>
		<package name="com.example.domain" />
	</typeAliases>
	
</configuration>

------------------------------------------------------------
-- 4일차 4교시 마이바이트설정, DB연동--
MemberMapper 인터페이스 생성
문장 붙일 때 + 앞에서 띄어주든 뒤에서 띄어주든 한칸은 띄어야함
pstmt = c.prepareStatement("INSERT INTO" + tblname + " VALUES("?,?,?,?")");
이것처럼 VALUES(#{id}, #{passwd}, #{name}, #{birthday}, #{gender}, #{email}, #{recvEmail}, #{regDate}), (), (), (), () ")
namespace 마이바티스 선택해줌
<mybatis-spring:scan base-package="com.example.mapper" />

MemberController에서 @PostMapping
//연월일 구분문자("-" 제거하기)
		String birthday = memberVO.getBirthday(); // "2021-08-25"
		birthday = birthday.replace("-", ""); // "20210825"
		memberVO.setBirthday(birthday);
------------------------------------------------------------
-- 4일차 5교시 회원가입 리다이렉트--
@Post로 보낼 때 회원가입 완료하고 로그인화면이 나오지만 주소창에 member/join나오는 이슈가 있다.
이 때 사용자가 새로고침을 누르면 한번더 작성내용 제출하게되는데, 보안상 좋지 않다.게다가 DB기본키제약 때문에 오류뜬다.
유니크제약조건만 하면 널 허용 // PK(프라이머리키) 는 널도 안되고 중복도안됨
그래서 
return "redirect:/member/login";
자바스크립트로는 location.href = '/'

그런데 리다이렉트를 바로 리턴하면 alert같은 창을 못띄우게된다.
그러므로 스프링방식으로 리다이렉트하는 방법을 익혀두자
자바스크립트가 담긴 html조각코드를 주려고 한다.
public ResponseEntity<String>

HttpHeaders headers = new HttpHeaders();
headers.add("Content-Type", "text/html; charset=UTF-8");어떠한 컨텐트 타입인지 미디어타입	
String str = Script.href("회원가입 성공!", "/member/login");	

return new ResponseEntity<String>(str, headers, HttpStatus.OK);
				문자열, 헤더정보, 응답코드(상수 200정상)

------------------------------------------------------------
-- 4일차 6교시 ResponseEntity사용법 --
return new ResponseEntity<String>(str, headers, HttpStatus.OK);
				문자열, 헤더정보, 응답코드(상수 200정상)
자주쓰는 패턴 별도의 클래스로만들기
com.example.util패키지에 Script.java 클래스로 만든다.
메서드 바로 호출 할 수 있드록 static처리
package com.example.util;

public class Script {

	public static String href(String alertMessage, String locationPath) {
		//sb.setLength(0);//StringBuilder 현재 내용 비우기
		StringBuilder sb = new StringBuilder();
		sb.append("<script>");
		sb.append("alert('" + alertMessage + "');");
		sb.append("location.href = '" + locationPath + "';");
		sb.append("</script>");
		
		return sb.toString();
	}
	
	public static String back(String alertMessage) {
		StringBuilder sb = new StringBuilder();
		sb.setLength(0);//StringBuilder 현재 내용 비우기 만약 버퍼를 안지우면?
		
		sb.append("<script>");
		sb.append("alert('" + alertMessage + "');");
		sb.append("history.back();");//뒤로가기
		sb.append("</script>");
		
		return sb.toString();
	}
}

------------------------------------------------------------
-- 4일차 7교시 --
------------------------------------------------------------
-- 5일차 1교시 --
------------------------------------------------------------
-- 5일차 2교시 --
------------------------------------------------------------
-- 5일차 3교시 --
------------------------------------------------------------
-- 5일차 4교시 --
------------------------------------------------------------
-- 5일차 5교시 --
------------------------------------------------------------
-- 5일차 6교시 --
------------------------------------------------------------
-- 5일차 7교시 --
------------------------------------------------------------
-- 6일차 1교시 --
------------------------------------------------------------
-- 6일차 2교시 --
------------------------------------------------------------
-- 6일차 3교시 --
------------------------------------------------------------
-- 6일차 4교시 --
------------------------------------------------------------
-- 6일차 5교시 --
------------------------------------------------------------
-- 6일차 6교시 --
------------------------------------------------------------
-- 6일차 7교시 --
------------------------------------------------------------
-- 7일차 1교시 게시판 글목록 페이징--
스크롤바
내리면 덧붙이는 방식
자바스크립트 방식으로 AJAX해야하는데 REST API방식으로 해야한다.

현재 우리는 서버쪽에서 렌더링 해주는 방식으로 쓰고 있는 중이다.

데이터는 Mysql에서 가져옴

LIMIT 몇번째 행부터 몇 개

페이지번호를 추가하면서 

페이지블록(페이지네이션)

인터페이스로 처리 하기때문에 버전바껴도 스프링이 알아서 해줌
integer.parseINt("2") 이런 과정도 스프링이 자동으로 해줌
그러므로 
@Controller
@RequestMapping("/board/*")
public class BoardController {
	@Autowired
	private BoardService boardService;
	
	@GetMapping("/list")
	public String list(int pageNum, int amount, Model model) { ->> 이부분은 Criteria criteria로 
		System.out.println("list 호출...");
		
		List<BoardVO> boardList = boardService.getBoards();
		
		int totalCount = boardService.getTotalCount(); //전체 글 개수
		//뷰에서 사용할 데이터를 Model 객체에 저장 - > requestScope로 옮겨줌
		model.addAttribute("boardList", boardList);
		model.addAttribute("totalCount", totalCount);
		
		return "board/boardList";
	}
	
}

pageNum과 amount를 domain으로 따로 관리하자
Criteria 클래스(조건관련된)

default설정 요청할 때 페이지번호 안넘어오면 1페이지로 기본
@Getter
@Setter
@ToString
public class Criteria {
	private int pageNum;
	private int amount;
	
	public Criteria() {
		this(1, 10);//기본값은 1페이지, 한페이지당 10개 글
	}

	public Criteria(int pageNum, int amount) {
		super();
		this.pageNum = pageNum;
		this.amount = amount;
	}
------------------------------------------------------------
-- 7일차2교시 paging, BoardMapper.xml, 페이지네이션 5개정도씩 끊어서 작성--

	[BoardMapper.xml]작성내용
	<select id="getBoardsWithPaging" resultType="com.example.domain.BoardVO">
	<![CDATA[
		SELECT * FROM board ORDER BY re_ref DESC LIMIT #{startRow}, #{amount}
	]]>
	</select>

pageDTO작성

페이지네이션
끝페이지부터 5개 노출


------------------------------------------------------------
-- 7일차3교시 paging, BoardMapper.xml, 페이지네이션 5개정도씩 끊어서 작성--
시작페이지와 끝페이지 알고리즘
endPage = (int)Math.ceil( (double)cri.getPageNum() / PAGE_BLOCK);
startPage = endPage


request스코프 생략내용 놓침...
<c:when test="${ pageMaker gt 0}">

<c:forEach var="" begin="${ pageMaker.startPage }" end="${ pageMaker.endPage }" step="1">
</c:forEach>

EL언어에서 ==는 eq이랑 같은 의미이다.

------------------------------------------------------------
-- 7일차4교시 paging, 페이지네이션 활성 비활성--
페이지네이션 활성 비활성
이전을 활성 비활성하는 거
JSTL c태그 복습하기
작성한 거: pageDTO, boardlist

------------------------------------------------------------
-- 7일차5교시 새글쓰기, 글 상세보기 --
it 필수로 갖춰야하는 점: 자기만의 취미생활
책임감이 너무 강하고 성실한 사람은 번아웃이 올 수 있다.

session 스코프~ 되는 거 기억해두고

session
가상으로 정적인것처럼 content.html 이런식으로 눈속임 할 수 있다. 물리주소는 아니다 .do


------------------------------------------------------------
-- 7일차6교시 게시글 상세보기, 글목록 세션처리보다는 request영역객체--
줄바꿈 문자 \n 
pre태그 쓰면 제일 쉽다
<pre>${ board ~~}</pre> 이거는 css로 글꼴 재지정해줘야한다.
onclick으로 한다는 것은 자바스크립트로 처리하는 것이다.
onclick = "location.href = '/board/boardList.jsp';"
글목록 누르면 좀전의 페이지네이션으로 돌아간다.
쿠키랑 비슷한 처리방식으로 했다.


------------------------------------------------------------
-- 7일차7교시 @ModelAttribute("pageNum")설명 --
답글쓰기(로그인한 사람만) 글삭제(글쓴이아이디와 동일) 글수정(글쓴이와 동일)
글쓴이와 같다는 것은 세션의 내용으로 알 수 있다.
requestScope생략 가능
새글쓰기 눌렀을 때 boardwrite
스프링 파일업로드 multipart
스프링은 cos방식과 다른 라이브러리를 받아들였다.
------------------------------------------------------------
-- 7일차8교시 @ModelAttribute설명 --
쿼리파라미터??
쿼리스트링
키 값
EL언어로

서버에 쿼리를 날리다.

C#이 자바를 벤치마킹해서 만들었다.

유니티, 언리얼

유니티는 C#언어로 돌아간다.
자바는 업무용
마인크래프트 자바
C#으로 포팅

------------------------------------------------------------
-- 8일차 1교시 --



